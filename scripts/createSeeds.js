#!/usr/bin/env node

const [
  knexfile = "knexfile.js",
  seedDir = "seeds",
  uploadDir = "uploads"
] = process.argv.slice(2);
const knex = require("knex");
const path = require("path");
const { execSync } = require("child_process");
const { writeFile, copyFile } = require("fs");
const fs = require("fs-extra");

const SEED_TEMPLATE = `// this file has been auto-generated by cotype seed creation
const data = :data;

exports.seed = knex =>
  knex(":name")
    .del()
    .then(() => {
      const seedData = [].concat(data);
      const chunks = [];

      while (seedData.length) {
        chunks.push(seedData.splice(0, 100));
      }

      return chunks.reduce(async (memo, chunk) => {
        await memo;

        return knex(":name").insert(chunk);
      }, Promise.resolve());
    });
`;

const tables = [
  "media",
  "roles",
  "users",
  "contents",
  "content_revisions",
  "content_values",
  "content_search",
  "content_references"
];

const leftpad = (str, len, ch) => {
  while (String(str).length < len) {
    str = `${ch}${str}`;
  }

  return str;
};

const db = knex(require(path.resolve(knexfile)));
const absSeedDir = path.resolve(seedDir);
fs.ensureFileSync(absSeedDir);
const absMediaDir = path.join(absSeedDir, "_media");

execSync(`rm -rf ${absSeedDir}; mkdir ${absSeedDir} && mkdir ${absMediaDir}`);

async function saveReferredMedia() {
  const contentReferences = await db.select().from("content_references");

  return Promise.all(
    contentReferences
      .filter(({ media }) => media)
      .map(({ media }) =>
        Promise.all([
          new Promise((resolve, reject) => {
            const destPath = path.resolve(absMediaDir, media);
            fs.ensureFileSync(destPath);
            copyFile(path.resolve(uploadDir, media), destPath, err =>
              err ? reject(err) : resolve()
            );
          }),
          new Promise((resolve, reject) => {
            const ext = path.extname(media);
            const dirname = path.dirname(media);
            const basename = path.basename(media, ext);
            const thumb = `${dirname}/${basename}.thumb.square${ext}`;
            const destPath = path.resolve(absMediaDir, thumb);
            fs.ensureFileSync(destPath);
            copyFile(path.resolve(uploadDir, thumb), destPath, err =>
              err ? reject(err) : resolve()
            );
          })
        ])
      )
  );
}

Promise.all(
  tables
    .map(async (tableName, i) => {
      const content = SEED_TEMPLATE.replace(/:name/g, tableName).replace(
        ":data",
        JSON.stringify(await db.select().from(tableName), null, 2)
      );
      return new Promise((resolve, reject) => {
        writeFile(
          path.resolve(absSeedDir, `${leftpad(i, 3, 0)}_${tableName}.js`),
          content,
          err => (err ? reject(err) : resolve())
        );
      });
    })
    .concat(saveReferredMedia())
)
  .then(db.destroy)
  .then(() => {
    console.log(
      `OK: Seeds have been created in ./${path.relative(
        process.cwd(),
        absSeedDir
      )}`
    );
  })
  .catch(err => {
    console.error(err);
    process.exit(1);
  });
